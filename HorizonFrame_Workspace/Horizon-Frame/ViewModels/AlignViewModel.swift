import SwiftUI
import Combine

class AlignViewModel: ObservableObject {
    // Holds all sessions; source of truth.
    @Published private var allSessions: [Session] = DummyData.sessions
    
    @Published var selectedDate: Date = Date()

    // Computed property for upcoming sessions on the selected date
    var upcomingSessionsForSelectedDate: [Session] {
        allSessions
            .filter { session in
                guard !session.isCompleted else { return false } // Not completed
                guard let sessionDate = session.date else { return false } // Must have a date
                // Compare if the session date is on the same day as selectedDate
                return Calendar.current.isDate(sessionDate, inSameDayAs: selectedDate)
            }
            .sorted { ($0.date ?? .distantFuture) < ($1.date ?? .distantFuture) } // Sort by actual time
    }

    // Computed property for completed sessions on the selected date
    var completedSessionsForSelectedDate: [Session] {
        allSessions
            .filter { session in
                guard session.isCompleted else { return false } // Must be completed
                guard let completedDate = session.completionDate else { return false } // Must have a completion date
                // Compare if the completion date is on the same day as selectedDate
                return Calendar.current.isDate(completedDate, inSameDayAs: selectedDate)
            }
            .sorted { ($0.completionDate ?? .distantFuture) < ($1.completionDate ?? .distantFuture) } // Sort by completion time
    }

    init() {
        // Initial setup if needed, allSessions is already populated.
        // Potentially load sessions from a persistent store here in a real app.
    }

    /// Mark the first upcoming session for the selectedDate as done.
    func markFirstUpcomingDone() {
        guard let firstSessionID = upcomingSessionsForSelectedDate.first?.id else { return }
        
        if let index = allSessions.firstIndex(where: { $0.id == firstSessionID }) {
            allSessions[index].isCompleted = true
            allSessions[index].completionDate = Date() // Mark completion with current time
            
            // Handle daily practice rescheduling
            if allSessions[index].isDailyPractice {
                rescheduleDailyPractice(for: allSessions[index])
            }
        }
    }
    
    private func rescheduleDailyPractice(for session: Session) {
        guard let originalDate = session.date else { return }
        if let nextDay = Calendar.current.date(byAdding: .day, value: 1, to: originalDate) {
            // Create a new session instance for the next day
            // This assumes the original session's other properties (like passage, title) remain the same.
            // A more robust approach might involve a template or specific logic for recurring sessions.
            let newSession = Session(
                // id: UUID(), // Removed: id is auto-generated by the Session struct
                title: session.title,
                passage: session.passage,
                date: nextDay,
                isDailyPractice: true, // It's still a daily practice
                isCompleted: false,    // New instance is not completed
                completionDate: nil
            )
            allSessions.append(newSession)
        }
    }

    func goToNextDay() {
        selectedDate = Calendar.current.date(byAdding: .day, value: 1, to: selectedDate) ?? selectedDate
    }

    func goToPreviousDay() {
        selectedDate = Calendar.current.date(byAdding: .day, value: -1, to: selectedDate) ?? selectedDate
    }
}